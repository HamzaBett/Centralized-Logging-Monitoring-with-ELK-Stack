# Logstash Pipeline Configuration
input {
  # Beats input for Filebeat
  beats {
    port => 5044
    ssl => true
    ssl_certificate => "${CERTIFICATE_AUTHORITIES}/logstash/logstash.crt"
    ssl_key => "${CERTIFICATE_AUTHORITIES}/logstash/logstash.key"
    ssl_key_passphrase => "${SSL_KEY_PASSPHRASE}"
  }
}

filter {
  # Parse JSON logs
  if [message] =~ /^\{.*\}$/ {
    json {
      source => "message"
      target => "json_data"
      remove_field => ["message"]
    }
  }

  # Grok patterns for unstructured logs
  else {
    grok {
      match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{GREEDYDATA:message}" }
      add_tag => ["grokked"]
    }
    
    # Handle multiline stack traces
    multiline {
      pattern => "^\\s+(at|Caused by)"
      what => "previous"
    }
  }

  # Add metadata
  mutate {
    add_field => {
      "environment" => "production"
      "service_name" => "%{[container][name]}"
      "version" => "1.0.0"
    }
    convert => {
      "response_time" => "float"
      "status_code" => "integer"
    }
  }

  # GeoIP enrichment for IP addresses
  if [client_ip] {
    geoip {
      source => "client_ip"
      target => "geoip"
      database => "/usr/share/logstash/vendor/geoip/GeoLite2-City.mmdb"
    }
  }

  # Date parsing
  date {
    match => [ "timestamp", "ISO8601", "yyyy-MM-dd HH:mm:ss,SSS" ]
    target => "@timestamp"
  }

  # Conditional routing based on log type
  if [json_data][level] == "ERROR" or [level] == "ERROR" {
    mutate {
      add_tag => ["error"]
    }
  }
  
  if [json_data][level] == "WARN" or [level] == "WARN" {
    mutate {
      add_tag => ["warning"]
    }
  }
}

output {
  # Send to Elasticsearch with index naming pattern
  elasticsearch {
    hosts => "${ELASTICSEARCH_URLS}"
    user => "${ELASTICSEARCH_USER}"
    password => "${ELASTICSEARCH_PASSWORD}"
    ssl => true
    ssl_certificate_verification => true
    cacert => "${CERTIFICATE_AUTHORITIES}/ca.crt"
    
    # Index naming pattern with date
    index => "logs-%{+YYYY.MM.dd}"
    
    # Use ILM for index management
    ilm_enabled => true
    ilm_rollover_alias => "${ILM_ROLLOVER_ALIAS}"
    ilm_pattern => "{now/d}-000001"
    ilm_policy => "${ILM_POLICY_NAME}"
    
    # Template management
    manage_template => false
    
    # Performance settings
    document_id => "%{[@metadata][_id]}"
    action => "create"
  }

  # Console output for debugging (comment out in production)
  # stdout {
  #   codec => rubydebug
  # }
}
